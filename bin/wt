#!/bin/bash
#
# wt - git worktree wrapper that manages worktrees in .worktrees/ by default
#
# Usage:
#   wt add <branch> [<start-point>]  - Create worktree (creates branch if needed)
#   wt ls                            - List all worktrees
#   wt rm <branch>                   - Remove a worktree
#   wt cd <branch>                   - Change to worktree directory
#   wt path <branch>                 - Show path to a worktree
#   wt prune                         - Clean up stale worktree references
#   wt <any-other-git-worktree-cmd>  - Pass through to git worktree
#
# Examples:
#   wt add feature/new-api           - Creates .worktrees/feature-new-api (new branch)
#   wt add main                      - Creates .worktrees/main (existing branch)
#   wt add fix-bug origin/main       - Creates new branch from origin/main
#   wt cd feature/new-api            - Change to worktree directory
#   wt rm feature/new-api            - Removes the worktree
#   wt ls                            - Shows all worktrees
#
# Tips:
#   - Branch names with slashes (feature/foo) become directories (feature-foo)
#   - 'wt cd' uses a shell function wrapper (in zsh/bostonaholic.plugin.zsh)
#   - Automatically detects if branch exists or needs to be created

set -eu -o pipefail

# Get the git repository root (main repo, not worktree)
get_repo_root() {
    # Get the common git directory, then go up one level to get repo root
    local git_common_dir
    git_common_dir=$(git rev-parse --path-format=absolute --git-common-dir 2>/dev/null)
    if [ -n "$git_common_dir" ]; then
        # Remove the /.git suffix to get the repo root
        dirname "$git_common_dir"
    fi
}

# Convert branch name to a safe directory name
# feature/new-api -> feature-new-api
sanitize_branch_name() {
    echo "$1" | sed 's/[\/:]/-/g'
}

# Get the worktree directory for a branch
get_worktree_dir() {
    local branch="$1"
    local repo_root
    repo_root=$(get_repo_root)
    local sanitized
    sanitized=$(sanitize_branch_name "$branch")
    echo "${repo_root}/.worktrees/${sanitized}"
}

# Command: wt add <branch> [<start-point>]
# Automatically creates branch if it doesn't exist, or uses existing branch
cmd_add() {
    if [ $# -lt 1 ]; then
        echo "Usage: wt add <branch> [<start-point>]" >&2
        exit 1
    fi

    local branch="$1"
    shift
    local start_point="${1:-}"

    local worktree_dir
    worktree_dir=$(get_worktree_dir "$branch")

    # Create .worktrees directory if it doesn't exist
    local repo_root
    repo_root=$(get_repo_root)
    mkdir -p "${repo_root}/.worktrees"

    # Check if branch exists (locally or remotely)
    local branch_exists=false
    if git show-ref --verify --quiet "refs/heads/${branch}" || \
       git show-ref --verify --quiet "refs/remotes/origin/${branch}"; then
        branch_exists=true
    fi

    # Build git worktree add command
    local cmd=(git worktree add)

    # If branch doesn't exist, add -b flag to create it
    if [ "$branch_exists" = false ]; then
        cmd+=(-b "$branch")
    fi

    # Add the path
    cmd+=("$worktree_dir")

    # For existing branches, add branch name
    if [ "$branch_exists" = true ]; then
        cmd+=("$branch")
    fi

    # Add start point if provided
    if [ -n "$start_point" ]; then
        cmd+=("$start_point")
    fi

    # Execute
    "${cmd[@]}"

    echo
    echo "Worktree created at: $worktree_dir"
    echo "To switch to it: cd $worktree_dir"
}

# Command: wt list
cmd_list() {
    git worktree list "$@"
}

# Command: wt remove <branch> [options]
cmd_remove() {
    if [ $# -lt 1 ]; then
        echo "Usage: wt remove <branch> [options]" >&2
        exit 1
    fi

    local branch="$1"
    shift
    local worktree_dir
    worktree_dir=$(get_worktree_dir "$branch")

    if [ ! -d "$worktree_dir" ]; then
        echo "Worktree not found: $worktree_dir" >&2
        echo "Available worktrees:" >&2
        git worktree list >&2
        exit 1
    fi

    git worktree remove "$@" "$worktree_dir"
}

# Command: wt prune
cmd_prune() {
    git worktree prune "$@"
}

# Command: wt path <branch>
cmd_path() {
    if [ $# -lt 1 ]; then
        echo "Usage: wt path <branch>" >&2
        exit 1
    fi

    local branch="$1"
    local worktree_dir
    worktree_dir=$(get_worktree_dir "$branch")

    if [ ! -d "$worktree_dir" ]; then
        echo "Worktree not found: $worktree_dir" >&2
        exit 1
    fi

    echo "$worktree_dir"
}

# Command: wt cd <branch>
# Prints path to worktree (shell function wrapper handles actual cd)
cmd_cd() {
    if [ $# -lt 1 ]; then
        echo "Usage: wt cd <branch>" >&2
        exit 1
    fi

    local branch="$1"
    local worktree_dir
    worktree_dir=$(get_worktree_dir "$branch")

    # Check if this worktree exists
    if [ ! -d "$worktree_dir" ]; then
        # Maybe it's the main repo? Check all worktrees to find where this branch is
        local repo_root
        repo_root=$(get_repo_root)
        local found_path
        found_path=$(git worktree list --porcelain | awk -v branch="$branch" '
            /^worktree / { path = substr($0, 10) }
            /^branch / {
                br = substr($0, 8)
                gsub(/^refs\/heads\//, "", br)
                if (br == branch) { print path; exit }
            }
        ')

        if [ -n "$found_path" ] && [ -d "$found_path" ]; then
            echo "$found_path"
        else
            echo "Worktree not found: $worktree_dir" >&2
            exit 1
        fi
    else
        # Print the path (shell function wrapper in zsh plugin uses this)
        echo "$worktree_dir"
    fi
}

# Main command dispatcher
main() {
    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: Not in a git repository" >&2
        exit 1
    fi

    # If no arguments, default to list
    if [ $# -eq 0 ]; then
        cmd_list
        exit 0
    fi

    local subcommand="$1"
    shift

    case "$subcommand" in
        add)
            cmd_add "$@"
            ;;
        ls)
            cmd_list "$@"
            ;;
        rm)
            cmd_remove "$@"
            ;;
        prune)
            cmd_prune "$@"
            ;;
        path)
            cmd_path "$@"
            ;;
        cd)
            cmd_cd "$@"
            ;;
        -h|--help|help)
            sed -n '2,/^$/p' "$0" | sed 's/^# \?//'
            ;;
        *)
            # Pass through to git worktree
            git worktree "$subcommand" "$@"
            ;;
    esac
}

main "$@"
