#!/usr/bin/env bash
set -euo pipefail

# wt - git worktree manager for bare-clone layouts
#
# Usage:
#   wt                            List all worktrees
#   wt ls                         List all worktrees
#   wt main                       Enter main/ worktree (creates if needed)
#   wt new <name> [<start-point>] Create worktree for a new branch (default: origin/main)
#   wt add <name>                 Create worktree for an existing branch
#   wt rm <name> [--keep-branch]  Remove worktree and delete local branch
#   wt cd <name>                  Enter a worktree by directory name
#   wt path <name>                Show path to a worktree
#   wt prune                      Clean up stale worktree references
#   wt help                       Show this help
#
# Requires a bare-clone layout created by 'git clone-bare-for-worktrees'.
# All worktrees are siblings of .bare/ in the project root.

# Find project root by walking up from cwd looking for .bare/ + .git pointer.
find_project_root() {
    local dir="$PWD"
    while [ "$dir" != "/" ]; do
        if [ -d "$dir/.bare" ] && [ -f "$dir/.git" ]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    return 1
}

require_bare_layout() {
    local root
    if ! root=$(find_project_root); then
        echo "Error: Not in a bare-clone worktree layout." >&2
        echo "Set up a project with: git clone-bare-for-worktrees <url>" >&2
        exit 1
    fi
    echo "$root"
}

validate_name() {
    local name="$1"
    if [[ "$name" == *".."* ]] || [[ "$name" == "/"* ]]; then
        echo "Error: Invalid worktree name '$name'" >&2
        exit 1
    fi
}

cmd_main() {
    local root
    root=$(require_bare_layout)
    local worktree_dir="$root/main"

    if [ ! -d "$worktree_dir" ]; then
        if git -C "$root" show-ref --verify --quiet "refs/heads/main"; then
            git -C "$root" worktree add main main >&2
        else
            git -C "$root" worktree add main >&2
        fi
    fi

    echo "$worktree_dir"
}

local_branch_exists() {
    local root="$1" name="$2"
    git -C "$root" show-ref --verify --quiet "refs/heads/$name"
}

remote_branch_exists() {
    local root="$1" name="$2"
    git -C "$root" show-ref --verify --quiet "refs/remotes/origin/$name"
}

cmd_new() {
    if [ $# -lt 1 ]; then
        echo "Usage: wt new <name> [<start-point>]" >&2
        exit 1
    fi

    local name="$1"
    shift
    local start_point="${1:-origin/main}"
    validate_name "$name"

    local root
    root=$(require_bare_layout)
    local worktree_dir="$root/$name"

    if [ -d "$worktree_dir" ]; then
        echo "Error: Worktree already exists: $name" >&2
        exit 1
    fi

    if local_branch_exists "$root" "$name"; then
        echo "Error: Local branch '$name' already exists. Use 'wt add $name' instead." >&2
        exit 1
    fi

    if remote_branch_exists "$root" "$name"; then
        echo "Error: Remote branch 'origin/$name' already exists. Use 'wt add $name' instead." >&2
        exit 1
    fi

    git -C "$root" worktree add --no-track -b "$name" "$worktree_dir" "$start_point" >&2
    echo "$worktree_dir"
}

cmd_add() {
    if [ $# -lt 1 ]; then
        echo "Usage: wt add <name>" >&2
        exit 1
    fi

    local name="$1"
    validate_name "$name"

    local root
    root=$(require_bare_layout)
    local worktree_dir="$root/$name"

    if [ -d "$worktree_dir" ]; then
        echo "Worktree already exists: $name" >&2
        echo "$worktree_dir"
        return 0
    fi

    if ! local_branch_exists "$root" "$name" && ! remote_branch_exists "$root" "$name"; then
        echo "Error: Branch '$name' not found locally or on origin. Use 'wt new $name' to create it." >&2
        exit 1
    fi

    git -C "$root" worktree add "$worktree_dir" "$name" >&2
    echo "$worktree_dir"
}

cmd_rm() {
    local keep_branch=false
    local name=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --keep-branch) keep_branch=true; shift ;;
            -*) echo "Unknown option: $1" >&2; exit 1 ;;
            *)  name="$1"; shift ;;
        esac
    done

    if [ -z "$name" ]; then
        echo "Usage: wt rm <name> [--keep-branch]" >&2
        exit 1
    fi

    validate_name "$name"

    if [ "$name" = "main" ]; then
        echo "Error: Cannot remove persistent worktree 'main'." >&2
        exit 1
    fi

    local root
    root=$(require_bare_layout)
    local worktree_dir="$root/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo "Worktree not found: $name" >&2
        git -C "$root" worktree list >&2
        exit 1
    fi

    git -C "$root" worktree remove "$worktree_dir"

    if [ "$keep_branch" = false ]; then
        if git -C "$root" show-ref --verify --quiet "refs/heads/$name"; then
            echo "Deleting local branch: $name"
            git -C "$root" branch -D "$name"
        fi
    fi

    git -C "$root" worktree prune
}

cmd_cd() {
    if [ $# -lt 1 ]; then
        echo "Usage: wt cd <name>" >&2
        exit 1
    fi

    local name="$1"
    validate_name "$name"
    local root
    root=$(require_bare_layout)
    local worktree_dir="$root/$name"

    if [ ! -d "$worktree_dir" ]; then
        echo "Worktree not found: $name" >&2
        exit 1
    fi

    echo "$worktree_dir"
}

cmd_path() {
    cmd_cd "$@"
}

cmd_list() {
    local root
    root=$(require_bare_layout)
    git -C "$root" worktree list "$@"
}

cmd_prune() {
    local root
    root=$(require_bare_layout)
    git -C "$root" worktree prune "$@"
}

cmd_help() {
    cat <<'EOF'
wt - git worktree manager for bare-clone layouts

Usage:
  wt                            List all worktrees
  wt ls                         List all worktrees
  wt main                       Enter main/ worktree (creates if needed)
  wt new <name> [<start-point>] Create worktree for a new branch (default: origin/main)
  wt add <name>                 Create worktree for an existing branch
  wt rm <name> [--keep-branch]  Remove worktree and delete local branch
  wt cd <name>                  Enter a worktree by directory name
  wt path <name>                Show path to a worktree
  wt prune                      Clean up stale worktree references
  wt help                       Show this help

Requires a bare-clone layout created by 'git clone-bare-for-worktrees'.
All worktrees are siblings of .bare/ in the project root.
EOF
}

# Hidden subcommand for zsh completions to get the project root.
cmd__root() {
    require_bare_layout
}

main() {
    if [ $# -eq 0 ]; then
        cmd_list
        exit 0
    fi

    local subcommand="$1"
    shift

    case "$subcommand" in
        main)           cmd_main "$@" ;;
        new)            cmd_new "$@" ;;
        add)            cmd_add "$@" ;;
        rm)             cmd_rm "$@" ;;
        ls)             cmd_list "$@" ;;
        cd)             cmd_cd "$@" ;;
        path)           cmd_path "$@" ;;
        prune)          cmd_prune "$@" ;;
        _root)          cmd__root ;;
        -h|--help|help) cmd_help ;;
        *)
            echo "Unknown command: $subcommand" >&2
            echo "Run 'wt help' for usage." >&2
            exit 1
            ;;
    esac
}

main "$@"
